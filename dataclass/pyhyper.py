## Imports
import gc, os, sys
import pathlib
from pathlib import Path
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import LogNorm
import xarray as xr
from tqdm.auto import tqdm  # progress bar loader!
from datetime import datetime
import importlib.util
import warnings

# Mute PyHyperScattering-wide UserWarnings
warnings.filterwarnings("ignore",
    ".*Unable to load optional dependency.*",
    category=UserWarning,
    module="PyHyperScattering"
)

## PyHyperScattering Imports
import PyHyperScattering as phs
print(f'Using PyHyperScattering Version: {phs.__version__}')

## Custom PyHyperScattering Class - Modified and Unmerged with pyhyperscattering

# Path to your local file
file_path = Path("/Users/keithwhite/repos/PyHyperScattering/src/"
                 "PyHyperScattering/PFFIGeneralIntegrator.py")

spec = importlib.util.spec_from_file_location("local_pffig", str(file_path))
local_pffig = importlib.util.module_from_spec(spec)
spec.loader.exec_module(local_pffig)

# Grab the custom class
PFFIGeneralIntegrator = local_pffig.PFFIGeneralIntegrator

## Single Image Example
# Example path to the .tiff file, collected from the load file dialog
dataPath = pathlib.Path('/Users/keithwhite/repos/ewald/example/sam22_1MAI1PbI2_unfilt_0p3M_5p0scfh_Si_30uL_043_2068.2s_x0.015_th0.300_0.49s_986546_001639_maxs.tiff')

# Example paths to the .poni and mask files collected from the load file dialog
## Calibrant Info: Select poni & mask filepaths
poniFile = pathlib.Path('/Users/keithwhite/repos/ewald/example/calib.poni')
maskFile = pathlib.Path('/Users/keithwhite/repos/ewald/example/mask.edf')

# Example metadata list generated by the load file dialog
metadata_list = ['sample', 'material', 'filter', 
                 'concentration', 'flowrate', 'substrate', 
                 'solution_volume', 'runNumber', 'global_time', 
                 'xpos', 'incident_angle', 'exposure_time', 
                 'scan_id', 'scan_number', 'detector']

# Create the GIWAXS Loader Object for Data Processing using PyHyperScattering
# This can be used for multiple images with the same metadata format.
fi_loader = phs.load.CMSGIWAXSLoader(md_naming_scheme=metadata_list)
# Once a loader is created, we can store that object and the associated metadata. We can add a dropdown to the load file dialog to select a previous loader and automatically populate the metadata fields.

# We need to create and manage the integrator object associated with this specific data.
# Each data object, either single image or stack, will have its own integrator object.
fi_integrator = PFFIGeneralIntegrator(
    geomethod='ponifile',   # Always set this to 'ponifile' 
    ponifile=poniFile, 
    maskmethod='edf',        # Automatically set this to 'edf' or 'json' based on the file extension of user input mask.
    maskpath=maskFile,
    sample_orientation=4,   # Add this as an input to the load file dialog, ranges from 1-8, restrict inputs to these values.
    incident_angle=0.3,     # This is an input in the load file dialog, default to 0.3.
    tilt_angle=0,           # Add this as an input in the load file dialog, same as incident angle, default to 0.
    split_pixels=True,      # Add this as an input in the load file dialog, default to True
    output_space='recip')   # Add this as an input in the load file dialog, dropdown with options 'Reciprocal Space', 'Polar (Azimuthal)', or 'both, default is reciprocal space and populates the filed with 'recip', we can add the other option details later.

# PyHyperscattering deals in two dataset output formats:
# 1. xarray dataset
util = phs.util.IntegrationUtils.CMSGIWAXS(sorted(fi_fileset), # this is just a list with a single file for a single image.
                                           fi_loader, 
                                           fi_integrator)
raw_DS, recip_DS = util.single_images_to_dataset()  # Create the raw and reciprocal space datasets

# Here is the code that generates the xarray datasets. Don't integrate in this code, just use it as a reference.
def single_images_to_dataset(self):
    """
    Method that takes a subscriptable object of filepaths corresponding to raw GIWAXS
    beamline data, loads the raw data into an xarray DataArray, generates pygix-transformed 
    cartesian and polar DataArrays, and creates 3 corresponding xarray Datasets 
    containing a DataArray per sample. 
    The raw dataarrays must contain the attributes 'scan_id' and 'incident_angle'

    Outputs: 2 Datasets: raw & reciprocal space (cartesian or polar based on integrator object)
    """
    # Select the first element of the sorted set outside of the for loop to initialize the xr.DataSet
    DA = self.loader.loadSingleImage(self.files[0])
    assert 'scan_id' in DA.attrs.keys(), "'scan_id' is a required attribute to use this function"

    # Update incident angle per sample:
    assert 'incident_angle' in DA.attrs.keys(), "'incident_angle' is a required attribute to use this function"
    self.integrator.incident_angle = float(DA.incident_angle[2:])

    # Integrate single image
    integ_DA = self.integrator.integrateSingleImage(DA)

    # Save coordinates for interpolating other dataarrays 
    integ_coords = integ_DA.coords

    # Create a DataSet, each DataArray will be named according to it's scan id
    raw_DS = DA.to_dataset(name=DA.scan_id)
    integ_DS = integ_DA.to_dataset(name=DA.scan_id)

    # Populate the DataSet with 
    for filepath in tqdm(self.files[1:], desc=f'Transforming Raw Data'):
        DA = self.loader.loadSingleImage(filepath)
        integ_DA = self.integrator.integrateSingleImage(DA)
        
        integ_DA = integ_DA.interp(integ_coords)

        raw_DS[f'{DA.scan_id}'] = DA
        integ_DS[f'{DA.scan_id}'] = integ_DA

    return raw_DS, integ_DS

# 2. numpy array
# This method will generate a set of numpy arrays for the raw and reciprocal space data. with files for each coordinate dimension that map to the image.
# Here is the code that generates the numpy arrays. Don't integrate in this code, just use it as a reference.
def save_processed_image(self,
                            processed_da: xr.DataArray,
                            base_name: str,
                            output_dir: str = None):
    """
    Save a processed xarray.DataArray and its coordinate arrays to .npy files.

    Parameters:
    -----------
    processed_da : xr.DataArray
        The processed DataArray (e.g., output of integrateSingleImage).
    base_name : str
        User-defined base name for files.
    output_dir : str, optional
        Directory in which to create the timestamped folder. Defaults to cwd.
    """
    # Generate timestamped folder name
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    folder_name = f"{base_name}_{timestamp}"
    target_root = output_dir or os.getcwd()
    target_folder = os.path.join(target_root, folder_name)
    os.makedirs(target_folder, exist_ok=True)

    # Save full data array
    data_path = os.path.join(target_folder, f"data_{folder_name}.npy")
    np.save(data_path, processed_da.values)

    # Save each coordinate separately
    for dim_name, coord in processed_da.coords.items():
        coord_path = os.path.join(target_folder,
                                    f"{dim_name}_{folder_name}.npy")
        np.save(coord_path, coord.values)

    print(f"Saved processed image and coordinates to: {target_folder}")